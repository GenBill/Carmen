# API 指数退避重试机制

## 🎯 设计目标

解决API限流导致的获取失败问题，提高数据获取成功率。

## 🔄 指数退避策略

### 基本原理
当API调用失败时，不是立即放弃，而是多次重试，且每次重试的等待时间呈指数增长。

### 重试参数
```python
max_retries = 3      # 最多重试3次
base_delay = 1       # 基础延迟1秒
```

### 延迟计算
```
第1次尝试: 失败后等待 1秒 (1 * 2^0)
第2次尝试: 失败后等待 2秒 (1 * 2^1)
第3次尝试: 失败后等待 4秒 (1 * 2^2)
总延迟: 最多7秒
```

## 📊 工作流程

```
API调用
  ↓
成功? ──是──→ 返回数据
  ↓ 否
第1次重试
  ↓
成功? ──是──→ 返回数据
  ↓ 否
等待1秒
  ↓
第2次重试
  ↓
成功? ──是──→ 返回数据
  ↓ 否
等待2秒
  ↓
第3次重试
  ↓
成功? ──是──→ 返回数据
  ↓ 否
等待4秒后最终失败
  ↓
返回None（跳过该股票）
```

## 💡 优势分析

### 1. 提高成功率
- **瞬时故障**: 网络抖动等临时问题可通过重试解决
- **限流恢复**: 给API服务器时间恢复配额
- **成功率提升**: 从单次尝试 → 3次尝试

### 2. 避免雪崩
- **指数退避**: 避免大量并发重试加重服务器压力
- **逐步增加延迟**: 给系统更多恢复时间
- **最终放弃**: 避免无限重试

### 3. 用户体验
- **自动恢复**: 无需手动干预
- **进度提示**: 显示重试状态
- **智能跳过**: 失败后继续处理其他股票

## 📝 输出示例

### 成功场景（第1次）
```
✅ 直接成功，无任何输出
```

### 成功场景（第2次重试成功）
```
⚠️  AAPL API调用失败 (尝试 1/3): HTTPError 429
   等待 1 秒后重试...
✅ 第2次成功，继续处理
```

### 失败场景（3次全失败）
```
⚠️  AAPL API调用失败 (尝试 1/3): HTTPError 429
   等待 1 秒后重试...
⚠️  AAPL API调用失败 (尝试 2/3): HTTPError 429
   等待 2 秒后重试...
❌ AAPL API调用最终失败 (已重试3次): HTTPError 429
```

## ⚙️ 配置调优

### 场景1: 网络稳定
```python
max_retries = 2      # 减少重试次数
base_delay = 0.5     # 减少延迟
```

### 场景2: API限流严重
```python
max_retries = 5      # 增加重试次数
base_delay = 2       # 增加基础延迟
# 总延迟: 2+4+8+16+32 = 62秒
```

### 场景3: 快速失败（开发调试）
```python
max_retries = 1      # 只尝试1次
base_delay = 0       # 无延迟
```

## 📈 性能对比

### 无重试机制
```
100个股票 × 5%失败率 = 5个失败
成功率: 95%
```

### 有重试机制（3次）
```
100个股票 × 5%失败率 × (1-95%成功率)^3 = 0.0125个失败
成功率: 99.99%
假设每次重试有50%成功率
```

## 🔍 错误类型处理

### 可重试错误
- ✅ 网络超时 (timeout)
- ✅ HTTP 429 (Too Many Requests)
- ✅ HTTP 503 (Service Unavailable)
- ✅ 连接重置

### 不应重试错误
- ❌ HTTP 404 (股票代码不存在)
- ❌ HTTP 401 (认证失败)
- ❌ 数据格式错误

**当前实现**: 对所有异常都重试（简单粗暴但有效）

## 🎯 最佳实践

### 1. 盘前扫描全nasdaq
```python
# 4000只股票，约5%失败率
# 无重试: 200个失败
# 有重试: <10个失败
```

### 2. 盘中监控自选股
```python
# 7只股票，API充足
# 重试机制作为保险，很少触发
```

### 3. 配合缓存使用
```python
# 第一次: API调用（可能重试）
# 后续: 使用缓存（无需API）
# 最佳组合：缓存 + 重试
```

## 📊 统计建议

### 添加重试统计（可选）
```python
total_attempts = 0
successful_retries = 0

if attempt > 0:
    successful_retries += 1
    
print(f"重试成功率: {successful_retries/total_attempts}")
```

## ⚠️ 注意事项

### 1. 时间成本
- 3次重试最多增加7秒
- 大规模扫描时会累积
- 建议：配合缓存使用

### 2. API配额
- 重试会消耗额外配额
- 但提高了成功率
- 权衡：可靠性 vs 配额

### 3. 用户体验
- 重试时会有延迟
- 显示进度很重要
- 最终失败要明确提示

## ✅ 总结

### 核心价值
1. **提高成功率**: 从95% → 99.99%
2. **自动恢复**: 无需人工干预
3. **智能退避**: 避免雪崩效应
4. **用户友好**: 清晰的进度提示

### 实现要点
- ✅ 指数退避算法
- ✅ 最大重试次数限制
- ✅ 友好的错误提示
- ✅ 与缓存机制配合

**推荐**: 生产环境建议启用此机制！
